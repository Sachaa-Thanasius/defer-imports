"""Tests for deferred.

Notes
-----
sys.modules.pop(module_name) before exec_module is prevalent to ensure that cached modules don't interfere, since the
deferred import hooks return cached modules if available instead of proxies in some cases.

A proxy's presence in a namespace is checked via stringifying the namespace and then substring matching with the
expected proxy repr, as that's the only way to inspect it without causing it to resolve.
"""

import ast
import importlib.machinery
import importlib.util
import io
import sys
import tokenize
from pathlib import Path

import pytest

from deferred._core import (
    DEFERRED_PATH_HOOK,
    DeferredFileLoader,
    DeferredInstrumenter,
    install_defer_import_hook,
    uninstall_defer_import_hook,
)


def create_sample_module(path: Path, source: str, loader_type: type):
    """Utility function for creating a sample module with the given path, source code, and loader."""

    tmp_file = path / "sample.py"
    tmp_file.write_text(source, encoding="utf-8")

    module_name = "sample"
    path = tmp_file.resolve()

    loader = loader_type(module_name, str(path))
    spec = importlib.util.spec_from_file_location(module_name, path, loader=loader)
    assert spec
    return spec, importlib.util.module_from_spec(spec)


@pytest.mark.parametrize(
    ("before", "after"),
    [
        pytest.param(
            """\
from deferred import defer_imports_until_use

with defer_imports_until_use:
    import inspect
""",
            """\
from deferred._core import DeferredImportKey as @DeferredImportKey, DeferredImportProxy as @DeferredImportProxy
from deferred import defer_imports_until_use
with defer_imports_until_use:
    @global_ns = globals()
    @temp_proxy = None
    import inspect
    if type(inspect) is @DeferredImportProxy:
        @temp_proxy = @global_ns.pop('inspect')
        @global_ns[@DeferredImportKey('inspect', @temp_proxy)] = @temp_proxy
    del @temp_proxy
    del @global_ns
del @DeferredImportKey
del @DeferredImportProxy
""",
            id="regular import",
        ),
        pytest.param(
            """\
from deferred import defer_imports_until_use


with defer_imports_until_use:
    import importlib
    import importlib.abc
""",
            """\
from deferred._core import DeferredImportKey as @DeferredImportKey, DeferredImportProxy as @DeferredImportProxy
from deferred import defer_imports_until_use
with defer_imports_until_use:
    @global_ns = globals()
    @temp_proxy = None
    import importlib
    if type(importlib) is @DeferredImportProxy:
        @temp_proxy = @global_ns.pop('importlib')
        @global_ns[@DeferredImportKey('importlib', @temp_proxy)] = @temp_proxy
    import importlib.abc
    if type(importlib) is @DeferredImportProxy:
        @temp_proxy = @global_ns.pop('importlib')
        @global_ns[@DeferredImportKey('importlib', @temp_proxy)] = @temp_proxy
    del @temp_proxy
    del @global_ns
del @DeferredImportKey
del @DeferredImportProxy
""",
            id="mixed import 1",
        ),
        pytest.param(
            """\
from deferred import defer_imports_until_use

with defer_imports_until_use:
    from . import a
""",
            """\
from deferred._core import DeferredImportKey as @DeferredImportKey, DeferredImportProxy as @DeferredImportProxy
from deferred import defer_imports_until_use
with defer_imports_until_use:
    @global_ns = globals()
    @temp_proxy = None
    from . import a
    if type(a) is @DeferredImportProxy:
        @temp_proxy = @global_ns.pop('a')
        @global_ns[@DeferredImportKey('a', @temp_proxy)] = @temp_proxy
    del @temp_proxy
    del @global_ns
del @DeferredImportKey
del @DeferredImportProxy
""",
            id="relative import 1",
        ),
    ],
)
def test_instrumentation(before: str, after: str):
    """Test what code is generated by the instrumentation side of deferred."""

    before_bytes = before.encode()
    encoding, _ = tokenize.detect_encoding(io.BytesIO(before_bytes).readline)

    transformer = DeferredInstrumenter("<unknown>", before_bytes, encoding)
    transformed_tree = ast.fix_missing_locations(transformer.visit(ast.parse(before)))

    assert f"{ast.unparse(transformed_tree)}\n" == after


def test_path_hook_installation():
    """Test the API for putting/removing the deferred path hook from sys.path_hooks."""

    # It shouldn't be on there by default.
    assert DEFERRED_PATH_HOOK not in sys.path_hooks
    before_length = len(sys.path_hooks)

    # It should be present after calling install.
    install_defer_import_hook()
    assert DEFERRED_PATH_HOOK in sys.path_hooks
    assert len(sys.path_hooks) == before_length + 1

    # Calling install shouldn't do anything if it's already on sys.path_hooks.
    install_defer_import_hook()
    assert DEFERRED_PATH_HOOK in sys.path_hooks
    assert len(sys.path_hooks) == before_length + 1

    # Calling uninstall should remove it.
    uninstall_defer_import_hook()
    assert DEFERRED_PATH_HOOK not in sys.path_hooks
    assert len(sys.path_hooks) == before_length

    # Calling uninstall if it's not present should do nothing to sys.path_hooks.
    uninstall_defer_import_hook()
    assert DEFERRED_PATH_HOOK not in sys.path_hooks
    assert len(sys.path_hooks) == before_length


class TestBasic:
    """Test a variety of regular, non-relative imports done within a defer_imports_until_use block."""

    def test_empty(self, tmp_path: Path):
        source = ""

        spec, module = create_sample_module(tmp_path, source, DeferredFileLoader)
        assert spec.loader
        spec.loader.exec_module(module)

    def test_regular_import(self, tmp_path: Path):
        source = """\
import sys

from deferred import defer_imports_until_use

with defer_imports_until_use:
    import inspect

# expected_inspect_repr = "<key for 'inspect' import>: <proxy for 'import inspect'>"
assert "<key for 'inspect' import>: <proxy for 'import inspect'>" in repr(vars())
assert inspect
assert "<key for 'inspect' import>: <proxy for 'import inspect'>" not in repr(vars())

assert inspect is sys.modules["inspect"]
assert str(inspect.signature(lambda a, c: c)) == "(a, c)"
"""

        spec, module = create_sample_module(tmp_path, source, DeferredFileLoader)
        assert spec.loader
        sys.modules.pop("inspect", None)  # Ensure it's fresh.
        spec.loader.exec_module(module)

    def test_regular_import_with_rename(self, tmp_path: Path):
        source = """\
import sys

import pytest
from deferred import defer_imports_until_use

with defer_imports_until_use:
    import inspect as gin

# expected_gin_repr = "<key for 'gin' import>: <proxy for 'import inspect'>"

assert "<key for 'gin' import>: <proxy for 'import inspect'>" in repr(vars())

with pytest.raises(NameError):
    inspect

assert "<key for 'gin' import>: <proxy for 'import inspect'>" in repr(vars())
assert gin
assert "<key for 'gin' import>: <proxy for 'import inspect'>" not in repr(vars())

assert sys.modules["inspect"] is gin
assert str(gin.signature(lambda a, b: b)) == "(a, b)"
"""

        spec, module = create_sample_module(tmp_path, source, DeferredFileLoader)
        assert spec.loader
        sys.modules.pop("inspect", None)
        spec.loader.exec_module(module)

    def test_regular_import_nested(self, tmp_path: Path):
        source = """\
import sys

from deferred import defer_imports_until_use

with defer_imports_until_use:
    import importlib.abc

# expected_importlib_repr = "<key for 'importlib' import>: <proxy for 'import importlib.abc'>"
assert "<key for 'importlib' import>: <proxy for 'import importlib.abc'>" in repr(vars())

assert importlib
assert importlib.abc
assert importlib.abc.MetaPathFinder

assert "<key for 'importlib' import>: <proxy for 'import importlib.abc'>" not in repr(vars())
"""

        spec, module = create_sample_module(tmp_path, source, DeferredFileLoader)
        assert spec.loader
        sys.modules.pop("importlib.abc", None)
        sys.modules.pop("importlib", None)
        spec.loader.exec_module(module)

    def test_regular_import_nested_with_rename(self, tmp_path: Path):
        source = """\
import sys

import pytest
from deferred import defer_imports_until_use

with defer_imports_until_use:
    import collections.abc as xyz

# Make sure the right proxy is in the namespace.
# expected_xyz_repr = "<key for 'xyz' import>: <proxy for 'import collections.abc as ...'>"
assert "<key for 'xyz' import>: <proxy for 'import collections.abc as ...'>" in repr(vars())

# Make sure the intermediate imports or proxies for them aren't in the namespace.
with pytest.raises(NameError):
    collections

with pytest.raises(NameError):
    collections.abc

# Make sure xyz resolves properly.
assert "<key for 'xyz' import>: <proxy for 'import collections.abc as ...'>" in repr(vars())
assert xyz
assert "<key for 'xyz' import>: <proxy for 'import collections.abc as ...'>" not in repr(vars())
assert xyz is sys.modules["collections"].abc

# Make sure only the resolved xyz remains in the namespace.
with pytest.raises(NameError):
    collections

with pytest.raises(NameError):
    collections.abc
"""

        spec, module = create_sample_module(tmp_path, source, DeferredFileLoader)
        assert spec.loader
        sys.modules.pop("collections.abc", None)
        sys.modules.pop("collections", None)
        spec.loader.exec_module(module)

    def test_from_import(self, tmp_path: Path):
        source = """\
import sys

import pytest
from deferred import defer_imports_until_use

with defer_imports_until_use:
    from inspect import isfunction, signature

assert "<key for 'isfunction' import>: <proxy for 'from inspect import isfunction'>" in repr(vars())
assert "<key for 'signature' import>: <proxy for 'from inspect import signature'>" in repr(vars())

with pytest.raises(NameError):
    inspect

assert "<key for 'isfunction' import>: <proxy for 'from inspect import isfunction'>" in repr(vars())
assert isfunction
assert "<key for 'isfunction' import>: <proxy for 'from inspect import isfunction'>" not in repr(vars())
assert isfunction is sys.modules["inspect"].isfunction

assert "<key for 'signature' import>: <proxy for 'from inspect import signature'>" in repr(vars())
assert signature
assert "<key for 'signature' import>: <proxy for 'from inspect import signature'>" not in repr(vars())
assert signature is sys.modules["inspect"].signature
"""

        spec, module = create_sample_module(tmp_path, source, DeferredFileLoader)
        assert spec.loader
        sys.modules.pop("inspect", None)
        spec.loader.exec_module(module)

    def test_from_import_with_rename(self, tmp_path: Path):
        source = """\
import sys

import pytest
from deferred import defer_imports_until_use

with defer_imports_until_use:
    from inspect import Signature as MySignature

assert "<key for 'MySignature' import>: <proxy for 'from inspect import Signature'>" in repr(vars())

with pytest.raises(NameError):
    inspect

with pytest.raises(NameError):
    Signature

assert "<key for 'MySignature' import>: <proxy for 'from inspect import Signature'>" in repr(vars())
assert str(MySignature) == "<class 'inspect.Signature'>"  # Resolves on use.
assert "<key for 'MySignature' import>: <proxy for 'from inspect import Signature'>" not in repr(vars())
assert MySignature is sys.modules["inspect"].Signature
"""

        spec, module = create_sample_module(tmp_path, source, DeferredFileLoader)
        assert spec.loader
        sys.modules.pop("inspect", None)
        spec.loader.exec_module(module)


class TestSyntaxError:
    """Test usage of defer_imports_until_usage that should raise syntax errors."""

    def test_error_if_non_import(self, tmp_path: Path):
        source = """\
from deferred import defer_imports_until_use

with defer_imports_until_use:
    print("Hello world")
"""

        # Boilerplate to dynamically create and load this module.
        tmp_file = tmp_path / "sample.py"
        tmp_file.write_text(source, encoding="utf-8")

        module_name = "sample"
        path = tmp_file.resolve()

        spec = importlib.util.spec_from_file_location(
            module_name, path, loader=DeferredFileLoader(module_name, str(path))
        )

        assert spec
        assert spec.loader

        module = importlib.util.module_from_spec(spec)

        with pytest.raises(SyntaxError) as exc_info:
            spec.loader.exec_module(module)

        assert exc_info.value.filename == str(path)
        assert exc_info.value.lineno == 4
        assert exc_info.value.offset == 5
        assert exc_info.value.text == 'print("Hello world")'

    def test_error_if_import_in_class(self, tmp_path: Path):
        source = """\
from deferred import defer_imports_until_use

class Example:
    with defer_imports_until_use:
        from inspect import signature
"""

        # Boilerplate to dynamically create and load this module.
        tmp_file = tmp_path / "sample.py"
        tmp_file.write_text(source, encoding="utf-8")

        module_name = "sample"
        path = tmp_file.resolve()

        spec = importlib.util.spec_from_file_location(
            module_name, path, loader=DeferredFileLoader(module_name, str(path))
        )

        assert spec
        assert spec.loader

        module = importlib.util.module_from_spec(spec)

        with pytest.raises(SyntaxError) as exc_info:
            spec.loader.exec_module(module)

        assert exc_info.value.filename == str(path)
        assert exc_info.value.lineno == 4
        assert exc_info.value.offset == 5
        assert exc_info.value.text == "    with defer_imports_until_use:\n        from inspect import signature"

    def test_error_if_import_in_function(self, tmp_path: Path):
        source = """\
from deferred import defer_imports_until_use

def test():
    with defer_imports_until_use:
        import inspect

    return inspect.signature(test)
"""

        # Boilerplate to dynamically create and load this module.
        tmp_file = tmp_path / "sample.py"
        tmp_file.write_text(source, encoding="utf-8")

        module_name = "sample"
        path = tmp_file.resolve()

        spec = importlib.util.spec_from_file_location(
            module_name, path, loader=DeferredFileLoader(module_name, str(path))
        )

        assert spec
        assert spec.loader

        module = importlib.util.module_from_spec(spec)

        with pytest.raises(SyntaxError) as exc_info:
            spec.loader.exec_module(module)

        assert exc_info.value.filename == str(path)
        assert exc_info.value.lineno == 4
        assert exc_info.value.offset == 5
        assert exc_info.value.text == "    with defer_imports_until_use:\n        import inspect"

    def test_error_if_wildcard_import(self, tmp_path: Path):
        source = """\
from deferred import defer_imports_until_use

with defer_imports_until_use:
    from typing import *
"""

        # Boilerplate to dynamically create and load this module.
        tmp_file = tmp_path / "sample.py"
        tmp_file.write_text(source, encoding="utf-8")

        module_name = "sample"
        path = tmp_file.resolve()

        spec = importlib.util.spec_from_file_location(
            module_name, path, loader=DeferredFileLoader(module_name, str(path))
        )

        assert spec
        assert spec.loader

        module = importlib.util.module_from_spec(spec)

        with pytest.raises(SyntaxError) as exc_info:
            spec.loader.exec_module(module)

        assert exc_info.value.filename == str(path)
        assert exc_info.value.lineno == 4
        assert exc_info.value.offset == 5
        assert exc_info.value.text == "from typing import *"


class TestMixedImportTypes:
    def test_top_level_and_submodules_1(self, tmp_path: Path):
        source = """\
from pprint import pprint

from deferred import defer_imports_until_use

with defer_imports_until_use:
    import importlib
    import importlib.abc
    import importlib.util

# expected_importlib_repr = "<key for 'importlib' import>: <proxy for 'import importlib'>"

# Test that the importlib proxy is here and then resolves.
assert "<key for 'importlib' import>: <proxy for 'import importlib'>" in repr(vars())
assert importlib
assert "<key for 'importlib' import>: <proxy for 'import importlib'>" not in repr(vars())
# pprint(vars(importlib))

# Test that the nested proxies carry over to the resolved importlib.
assert "<key for 'abc' import>: <proxy for 'import importlib.abc as ...'>" in repr(vars(importlib))
assert "<key for 'util' import>: <proxy for 'import importlib.util as ...'>" in repr(vars(importlib))

assert "<key for 'abc' import>: <proxy for 'import importlib.abc as ...'>" in repr(vars(importlib))
importlib.abc
assert "<key for 'abc' import>: <proxy for 'import importlib.abc as ...'>" not in repr(vars(importlib))

assert "<key for 'util' import>: <proxy for 'import importlib.util as ...'>" in repr(vars(importlib))
importlib.util
assert "<key for 'util' import>: <proxy for 'import importlib.util as ...'>" not in repr(vars(importlib))
"""
        spec, module = create_sample_module(tmp_path, source, DeferredFileLoader)
        assert spec.loader
        for key in list(sys.modules):
            if key == "importlib" or key.startswith("importlib."):
                sys.modules.pop(key)
        spec.loader.exec_module(module)

    def test_top_level_and_submodules_2(self, tmp_path: Path):
        source = """\
from pprint import pprint

from deferred import defer_imports_until_use

with defer_imports_until_use:
    import asyncio
    import asyncio.base_events
    import asyncio.base_futures
    import asyncio.base_subprocess
    import asyncio.base_tasks
    import asyncio.constants
    import asyncio.coroutines
    import asyncio.events
    import asyncio.format_helpers
    import asyncio.futures
    import asyncio.locks
    import asyncio.log
    import asyncio.proactor_events
    import asyncio.protocols
    import asyncio.queues
    import asyncio.runners
    import asyncio.selector_events
    import asyncio.sslproto
    import asyncio.streams
    import asyncio.subprocess
    import asyncio.tasks
    import asyncio.transports
    import asyncio.unix_events
"""
        spec, module = create_sample_module(tmp_path, source, DeferredFileLoader)
        assert spec.loader
        for key in list(sys.modules):
            if key == "asyncio" or key.startswith("asyncio."):
                sys.modules.pop(key)
        spec.loader.exec_module(module)

    def test_mixed_from_same_module(self, tmp_path: Path):
        source = """\
import sys

from deferred import defer_imports_until_use


with defer_imports_until_use:
    import asyncio
    from asyncio import base_events
    from asyncio import base_futures

# Make sure the right proxies are present.
assert "<key for 'asyncio' import>: <proxy for 'import asyncio'>" in repr(vars())
assert "<key for 'base_events' import>: <proxy for 'from asyncio import base_events'>" in repr(vars())
assert "<key for 'base_futures' import>: <proxy for 'from asyncio import base_futures'>" in repr(vars())

# Make sure resolving one proxy doesn't resolve or void the others.
assert base_futures
assert base_futures is sys.modules["asyncio.base_futures"]
assert "<key for 'base_futures' import>: <proxy for 'from asyncio import base_futures'>" not in repr(vars())
assert "<key for 'base_events' import>: <proxy for 'from asyncio import base_events'>" in repr(vars())
assert "<key for 'asyncio' import>: <proxy for 'import asyncio'>" in repr(vars())

assert base_events
assert base_events is sys.modules["asyncio.base_events"]
assert "<key for 'base_events' import>: <proxy for 'from asyncio import base_events'>" not in repr(vars())
assert "<key for 'base_futures' import>: <proxy for 'from asyncio import base_futures'>" not in repr(vars())
assert "<key for 'asyncio' import>: <proxy for 'import asyncio'>" in repr(vars())

assert asyncio
assert asyncio is sys.modules["asyncio"]
assert "<key for 'base_events' import>: <proxy for 'from asyncio import base_events'>" not in repr(vars())
assert "<key for 'base_futures' import>: <proxy for 'from asyncio import base_futures'>" not in repr(vars())
assert "<key for 'asyncio' import>: <proxy for 'import asyncio'>" not in repr(vars())
"""

        spec, module = create_sample_module(tmp_path, source, DeferredFileLoader)
        assert spec.loader
        for key in list(sys.modules):
            if key == "asyncio" or key.startswith("asyncio."):
                sys.modules.pop(key)
        spec.loader.exec_module(module)


class TestRelativeImports:
    def test_relative_imports_1(self, tmp_path: Path):
        """Test a synthetic package that uses relative imports within defer_imports_until_use blocks.

        The package has the following structure:

            sample_package
            ├───__init__.py
            ├───a.py
            └───b.py
        """

        sample_package_path = tmp_path / "sample_package"
        sample_package_path.mkdir()
        sample_package_path.joinpath("__init__.py").write_text(
            """\
from deferred import defer_imports_until_use

with defer_imports_until_use:
    from . import a
    from .a import A
    from .b import B

__all__ = ("A", "B")
"""
        )
        sample_package_path.joinpath("a.py").write_text(
            """\
class A:
    def __init__(self, val: object):
        self.val = val
"""
        )
        sample_package_path.joinpath("b.py").write_text(
            """\
class B:
    def __init__(self, val: object):
        self.val = val
"""
        )

        package_name = "sample_package"
        init_path = str(sample_package_path / "__init__.py")

        loader = DeferredFileLoader(package_name, init_path)
        spec = importlib.util.spec_from_file_location(
            package_name,
            init_path,
            loader=loader,
            submodule_search_locations=[],
        )
        assert spec
        assert spec.loader

        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        module_vars = repr(vars(module))

        assert "<key for 'a' import>: <proxy for 'from sample_package import a'>" in module_vars
        assert "<key for 'A' import>: <proxy for 'from sample_package.a import A'>" in module_vars
        assert "<key for 'B' import>: <proxy for 'from sample_package.b import B'>" in module_vars

        # FIXME: Why can't the original __import__ find sample_package? Is it a sys.path issue?
        assert module.A


class TestFalseCircularImports:
    # TODO
    pass


class TestTrueCircularImports:
    # TODO
    pass


class TestThreadSafety:
    # TODO
    pass
